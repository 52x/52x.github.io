<!DOCTYPE html>
<html lang="zh">
    <head>
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.3.4 -->

    <!-- Title -->
    
    <title>
        
            Device Tree（三）：代码分析 | 
        
        Hexo
    </title>

    <!-- Meta & Info -->
    <meta charset="utf-8">

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">
    
    
    
    
    
    

    <meta http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#0097A7">
    <meta name="author" content="John Doe">
    <meta name="description" content="null">
    <meta name="keywords" content="null,DevTree">

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" sizes="192x192" href="/img/favicon.png">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!--iOS -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-title" content="Title">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="480">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Hexo">

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://yoursite.com">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="Device Tree（三）：代码分析 | Hexo">
    <meta property="og:description" content="null">
    <meta property="og:article:tag" content="DevTree"> 

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import CSS & jQuery -->
    
        <link rel="stylesheet" href="/css/material.min.css">
        <link rel="stylesheet" href="/css/style.min.css">
        <!-- Config CSS -->


<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


        <script src="/js/jquery.min.js"></script>
        <script src="/js/queue.js"></script>
    

    <!-- UC Browser Compatible -->
    <script>
        var agent = navigator.userAgent.toLowerCase();
        if(agent.indexOf('ucbrowser')>0) {
            document.write("<link rel=\"stylesheet\" href=\"/css/uc.css\">");
            alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
        }
    </script>

    

    


    <!-- Bing Background -->
    

    <!-- Custom Head -->
    
</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->

    <!-- Left aligned menu below button -->
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#undefined"><span class="post-toc-number">1.</span> <span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#undefined"><span class="post-toc-number">2.</span> <span class="post-toc-text">如何通过Device Tree实现运行时参数传递以及platform的识别？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#undefined"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">汇编部分的代码分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#undefined"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">和device tree相关的setup_arch代码分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#undefined"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">匹配platform（machine描述符）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#undefined"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">运行时参数传递</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#undefined"><span class="post-toc-number">3.</span> <span class="post-toc-text">初始化流程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#undefined"><span class="post-toc-number">4.</span> <span class="post-toc-text">如何并入linux kernel的设备驱动模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#undefined"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">cpus node的处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#undefined"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">memory的处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#undefined"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">interrupt controller的处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#undefined"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">GPIO controller的处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#undefined"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">machine初始化</span></a></li></ol></li></ol>

        <!--
        <li class="mdl-menu__item">
            Some Action
        </li>
        -->
    </ul>




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script>
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                Device Tree（三）：代码分析
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>John Doe</strong>
        <span>4月 22, 2015</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/DevTree/">DevTree</a>
    </ul>
    

    <!-- Share -->
    <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=Device Tree（三）：代码分析&url=http://yoursite.com//2015/04/22/dt-code-analysis/index.html&pic=&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=Device Tree（三）：代码分析&url=http://yoursite.com//2015/04/22/dt-code-analysis/index.html&via=John Doe" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com//2015/04/22/dt-code-analysis/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://yoursite.com//2015/04/22/dt-code-analysis/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <p>原文链接：<a href="http://www.wowotech.net/linux_kenrel/dt-code-analysis.html" target="_blank" rel="external">http://www.wowotech.net/linux_kenrel/dt-code-analysis.html</a>
转自：<a href="www.wowotech.net">蜗窝科技</a></p>
<h2>前言</h2>
<p>Device Tree总共有三篇，分别是：</p>
<p>1、为何要引入Device Tree，这个机制是用来解决什么问题的？（请参考<a href="http://www.wowotech.net/linux_kenrel/why-dt.html" target="_blank" rel="external">引入Device Tree的原因</a>）
2、Device Tree的基础概念（请参考<a href="http://www.wowotech.net/linux_kenrel/dt_basic_concept.html" target="_blank" rel="external">DT基础概念</a>）
3、ARM linux中和Device Tree相关的代码分析（这是本文的主题）</p>
<p>本文主要内容是：以Device Tree相关的数据流分析为索引，对ARM linux kernel的代码进行解析。主要的数据流包括：</p>
<p>1、初始化流程。也就是扫描dtb并将其转换成Device Tree Structure。
2、运行时参数传递以及platform的识别流程分析
3、如何将Device Tree Structure并入linux kernel的设备驱动模型。</p>
<p>注：本文中的linux kernel使用的是3.14版本。
&lt;!--more--&gt;</p>
<h2>如何通过Device Tree实现运行时参数传递以及platform的识别？</h2>
<h3>汇编部分的代码分析</h3>
<p>linux/arch/arm/kernel/head.S文件定义了bootloader和kernel的参数传递要求：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MMU = off, D-cache = off, I-cache = dont care, r0 = 0, r1 = machine nr, r2 = atags or dtb pointer.</div></pre></td></tr></table></figure></p>
<p>目前的kernel支持旧的tag list的方式，同时也支持device tree的方式。<code>r2</code>可能是device tree binary file的指针（bootloader在传递给内核之前要copy到memory中），也可以能是tag list的指针。在ARM的汇编部分的启动代码中（主要是head.S和head-common.S），machine type ID和指向DTB或者atags的指针被保存在变量<code>__machine_arch_type</code>和<code>__atags_pointer</code>中，这么做是为了后续c代码进行处理。</p>
<h3>和device tree相关的setup_arch代码分析</h3>
<p>具体的c代码都是在<code>setup_arch</code>中处理，这个函数是一个总的入口点。具体代码如下（删除了部分无关代码）：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">setup_arch</span><span class="params">(<span class="keyword">char</span> **cmdline_p)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> machine_desc *mdesc;</div><div class="line">    ……</div><div class="line">    mdesc = setup_machine_fdt(__atags_pointer);</div><div class="line">    <span class="keyword">if</span> (!mdesc)</div><div class="line">        mdesc = setup_machine_tags(__atags_pointer, __machine_arch_type);</div><div class="line">    machine_desc = mdesc;</div><div class="line">    machine_name = mdesc-&gt;name;</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于如何确定HW platform这个问题，旧的方法是静态定义若干的machine描述符（<code>struct machine_desc</code>），在启动过程中，通过machine type ID作为索引，在这些静态定义的machine描述符中扫描，找到那个ID匹配的描述符。在新的内核中，首先使用<code>setup_machine_fdt</code>来setup machine描述符，如果返回NULL，才使用传统的方法<code>setup_machine_tags</code>来setup machine描述符。传统的方法需要给出<code>__machine_arch_type</code>（bootloader通过<code>r1</code>寄存器传递给kernel）和tag list的地址（用来进行tag parse）。<code>__machine_arch_type</code>用来寻找machine描述符；tag list用于运行时参数的传递。随着内核的不断发展，相信有一天linux kernel会完全抛弃tag list的机制。</p>
<h3>匹配platform（machine描述符）</h3>
<p><code>setup_machine_fdt</code>函数的功能就是根据Device Tree的信息，找到最适合的machine描述符。具体代码如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">struct</span> machine_desc * __<span class="function">init <span class="title">setup_machine_fdt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> dt_phys)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> machine_desc *mdesc, *mdesc_best = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!dt_phys || !early_init_dt_scan(phys_to_virt(dt_phys)))</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!mdesc) &#123;</div><div class="line">        <span class="comment">/* 出错处理 */</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Change machine number to match the mdesc we're using */</span></div><div class="line">    __machine_arch_type = mdesc-&gt;nr;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> mdesc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>early_init_dt_scan</code>函数有两个功能，一个是为后续的DTB scan进行准备工作，另外一个是运行时参数传递。具体请参考下面一个section的描述。</p>
<p><code>of_flat_dt_match_machine</code>是在machine描述符的列表中scan，找到最合适的那个machine描述符。我们首先看如何组成machine描述符的列表。和传统的方法类似，也是静态定义的。<code>DT_MACHINE_START</code>和<code>MACHINE_END</code>用来定义一个machine描述符。编译的时候，compiler会把这些machine descriptor放到一个特殊的段中（<code>.arch.info.init</code>），形成machine描述符的列表。machine描述符用下面的数据结构来标识（删除了不相关的member）：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> machine_desc &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        nr;         <span class="comment">/* architecture number */</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span>   *dt_compat; <span class="comment">/* array of device tree 'compatible' strings */</span></div><div class="line">    ……</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>nr</code>成员就是过去使用的machine type ID。内核machine描述符的table有若干个entry，每个都有自己的ID。bootloader传递了machine type ID，指明使用哪一个machine描述符。目前匹配machine描述符使用compatible strings，也就是<code>dt_compat</code>成员，这是一个string list，定义了这个machine所支持的列表。在扫描machine描述符列表的时候需要不断的获取下一个machine描述符的compatible字符串的信息，具体的代码如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> * __<span class="function">init <span class="title">arch_get_next_mach</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> **match)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> machine_desc *mdesc = __arch_info_begin;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> machine_desc *m = mdesc;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m &gt;= __arch_info_end)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    mdesc++;</div><div class="line">    *match = m-&gt;dt_compat;</div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>__arch_info_begin</code>指向machine描述符列表第一个entry。通过<code>mdesc++</code>不断的移动machine描述符指针（Note：<code>mdesc</code>是static的）。<code>match</code>返回了该machine描述符的compatible string list。具体匹配的算法倒是很简单，就是比较字符串而已，一个是root node的compatible字符串列表，一个是machine描述符的compatible字符串列表，得分最低的（最匹配的）就是我们最终选定的machine type。</p>
<h3>运行时参数传递</h3>
<p>运行时参数是在扫描DTB的<code>chosen node</code>时候完成的，具体的动作就是获取<code>chosen node</code>的<code>bootargs</code>、<code>initrd</code>等属性的value，并将其保存在全局变量（<code>boot_command_line</code>、<code>initrd_start</code>、<code>initrd_end</code>）中。使用tag list的方法是类似的，通过分析tag list，获取相关信息，保存在同样的全局变量中。具体代码位于<code>early_init_dt_scan</code>函数中：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> __<span class="function">init <span class="title">early_init_dt_scan</span><span class="params">(<span class="keyword">void</span> *params)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!params)</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 全局变量initial_boot_params指向了DTB的header */</span></div><div class="line">    initial_boot_params = params;</div><div class="line"></div><div class="line">    <span class="comment">/* 检查DTB的magic，确认是一个有效的DTB */</span></div><div class="line">    <span class="keyword">if</span> (be32_to_cpu(initial_boot_params-&gt;magic) != OF_DT_HEADER) &#123;</div><div class="line">        initial_boot_params = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 扫描 /chosen node，保存运行时参数（bootargs）到boot_command_line，</span></div><div class="line">     * 此外，还处理initrd相关的property，并保存在initrd_start和initrd_end这两个全局变量中</div><div class="line">     */</div><div class="line">    of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</div><div class="line"></div><div class="line">    <span class="comment">/* 扫描根节点，获取 &#123;size,address&#125;-cells信息，</span></div><div class="line">     * 并保存在dt_root_size_cells和dt_root_addr_cells全局变量中</div><div class="line">     */</div><div class="line">    of_scan_flat_dt(early_init_dt_scan_root, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* 扫描DTB中的memory node，并把相关信息保存在meminfo中，</span></div><div class="line">     * 全局变量meminfo保存了系统内存相关的信息。</div><div class="line">     */</div><div class="line">    of_scan_flat_dt(early_init_dt_scan_memory, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设定meminfo（该全局变量确定了物理内存的布局）有若干种途径：</p>
<p>1、通过tag list（tag是ATAG_MEM）传递memory bank的信息。
2、通过command line（可以用tag list，也可以通过DTB）传递memory bank的信息。
3、通过DTB的memory node传递memory bank的信息。</p>
<p>目前当然是推荐使用Device Tree的方式来传递物理内存布局信息。</p>
<h2>初始化流程</h2>
<p>在系统初始化的过程中，我们需要将DTB转换成节点是<code>device_node</code>的树状结构，以便后续方便操作。具体的代码位于<code>setup_arch-&gt;unflatten_device_tree</code>中。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">unflatten_device_tree</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    __unflatten_device_tree(initial_boot_params, &amp;of_allnodes,</div><div class="line">                early_init_dt_alloc_memory_arch);</div><div class="line"></div><div class="line">    <span class="comment">/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */</span></div><div class="line">    of_alias_scan(early_init_dt_alloc_memory_arch);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们用<code>struct device_node</code>来抽象设备树中的一个节点，具体解释如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> device_node &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;               <span class="comment">/* device node name */</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;               <span class="comment">/* 对应device_type的属性 */</span></div><div class="line">    phandle phandle;                <span class="comment">/* 对应该节点的phandle属性 */</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *full_name;          <span class="comment">/* 从“/”开始的，表示该node的full path */</span></div><div class="line"></div><div class="line">    <span class="keyword">struct</span>    property *properties; <span class="comment">/* 该节点的属性列表 */</span></div><div class="line">    <span class="keyword">struct</span>    property *deadprops;  <span class="comment">/* 如果需要删除某些属性，kernel并非真的删除，而是挂入到deadprops的列表 */</span></div><div class="line">    <span class="keyword">struct</span>    device_node *parent;  <span class="comment">/* parent、child以及sibling将所有的device node连接起来 */</span></div><div class="line">    <span class="keyword">struct</span>    device_node *child;</div><div class="line">    <span class="keyword">struct</span>    device_node *sibling;</div><div class="line">    <span class="keyword">struct</span>    device_node *next;    <span class="comment">/* 通过该指针可以获取相同类型的下一个node */</span></div><div class="line">    <span class="keyword">struct</span>    device_node *allnext; <span class="comment">/* 通过该指针可以获取node global list下一个node */</span></div><div class="line">    <span class="keyword">struct</span>    proc_dir_entry *pde;  <span class="comment">/* 开放到userspace的proc接口信息 */</span></div><div class="line">    <span class="keyword">struct</span>    kref kref;            <span class="comment">/* 该node的reference count */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _flags;</div><div class="line">    <span class="keyword">void</span>    *data;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>unflatten_device_tree</code>函数的主要功能就是扫描DTB，将device node组织成：</p>
<p>1、global list。全局变量<code>struct device_node *of_allnodes</code>就是指向设备树的global list
2、tree。</p>
<p>这些功能主要是在<code>__unflatten_device_tree</code>函数中实现，具体代码如下（去掉一些无关紧要的代码）：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __unflatten_device_tree(<span class="keyword">struct</span> boot_param_header *blob, <span class="comment">/* 需要扫描的DTB */</span></div><div class="line">                 <span class="keyword">struct</span> device_node **mynodes,                      <span class="comment">/* global list指针 */</span></div><div class="line">                 <span class="keyword">void</span> * (*dt_alloc)(u64 size, u64 align))           <span class="comment">/* 内存分配函数 */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</div><div class="line">    <span class="keyword">void</span> *start, *mem;</div><div class="line">    <span class="keyword">struct</span> device_node **allnextp = mynodes;</div><div class="line"></div><div class="line">    <span class="comment">/* 此处删除了health check代码，例如检查DTB header的magic，确认blob的确指向一个DTB。 */</span></div><div class="line"></div><div class="line">    <span class="comment">/* scan过程分成两轮，第一轮主要是确定device-tree structure的长度，保存在size变量中 */</span></div><div class="line">    start = ((<span class="keyword">void</span> *)blob) + be32_to_cpu(blob-&gt;off_dt_struct);</div><div class="line">    size = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)unflatten_dt_node(blob, <span class="number">0</span>, &amp;start, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</div><div class="line">    size = ALIGN(size, <span class="number">4</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* 初始化的时候，并不是扫描到一个node或者property就分配相应的内存，</span></div><div class="line">     * 实际上内核是一次性的分配了一大片内存，这些内存包括了所有的</div><div class="line">     * struct device_node、node name、struct property所需要的内存。</div><div class="line">     */</div><div class="line">    mem = dt_alloc(size + <span class="number">4</span>, __alignof__(<span class="keyword">struct</span> device_node));</div><div class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, size);</div><div class="line"></div><div class="line">    *(__be32 *)(mem + size) = cpu_to_be32(<span class="number">0xdeadbeef</span>); <span class="comment">/* 用来检验后面unflattening是否溢出 */</span></div><div class="line"></div><div class="line">    <span class="comment">/* 这是第二轮的scan，第一次scan是为了得到保存所有node和property所需要的内存size，</span></div><div class="line">     * 第二次就是实打实的要构建device node tree了</div><div class="line">     */</div><div class="line">    start = ((<span class="keyword">void</span> *)blob) + be32_to_cpu(blob-&gt;off_dt_struct);</div><div class="line">    unflatten_dt_node(blob, mem, &amp;start, <span class="literal">NULL</span>, &amp;allnextp, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* 此处略去校验溢出和校验OF_DT_END。 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体的scan是在<code>unflatten_dt_node</code>函数中，如果已经清楚地了解DTB的结构，其实代码很简单，这里就不再细述了。</p>
<h2>如何并入linux kernel的设备驱动模型</h2>
<p>在linux kernel引入统一设备模型之后，<code>bus</code>、<code>driver</code>和<code>device</code>形成了设备模型中的铁三角。在驱动初始化的时候会将代表该driver的一个数据结构（一般是<code>xxx_driver</code>）挂入bus上的driver链表。device挂入链表分成两种情况，一种是即插即用类型的bus，在插入一个设备后，总线可以检测到这个行为并动态分配一个device数据结构（一般是<code>xxx_device</code>，例如usb_device），之后，将该数据结构挂入bus上的device链表。bus上挂满了driver和device，那么如何让device遇到“对”的那个driver呢？那么就要靠缘分了，也就是bus的<code>match</code>函数。</p>
<p>上面是一段导论，我们还是回到Device Tree。导致Device Tree的引入ARM体系结构的代码其中一个最重要的原因的太多的静态定义的表格。例如：一般代码中会定义一个<code>static struct platform_device *xxx_devices</code>的静态数组，在初始化的时候调用<code>platform_add_devices</code>。这些静态定义的<code>platform_device</code>往往又需要静态定义各种<code>resource</code>，这导致静态表格进一步增大。如果ARM linux中不再定义这些表格，那么一定需要一个转换的过程，也就是说，系统应该会根据Device tree来动态的增加系统中的platform_device。当然，这个过程并非只是发生在platform bus上（具体可以参考<a href="http://www.wowotech.net/linux_kenrel/platform_device.html" target="_blank" rel="external">“Platform Device”的设备</a>），也可能发生在其他的非即插即用的bus上，例如AMBA总线、PCI总线。一言以蔽之，如果要并入linux kernel的设备驱动模型，那么就需要根据<code>device_node</code>的树状结构（root是<code>of_allnodes</code>）将一个个的device node挂入到相应的总线device链表中。只要做到这一点，总线机制就会安排device和driver的约会。</p>
<p>当然，也不是所有的device node都会挂入bus上的设备链表，比如cpus node，memory node，choose node等。</p>
<h3>cpus node的处理</h3>
<p>这部分的处理可以参考<code>setup_arch-&gt;arm_dt_init_cpu_maps</code>中的代码，具体的代码如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">arm_dt_init_cpu_maps</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/* scan device node global list，寻找full path是“/cpus”的那个device node。</span></div><div class="line">     * cpus这个device node只是一个容器，其中包括了各个cpu node的定义以及所有cpu node共享的property。</div><div class="line">     */</div><div class="line">    cpus = of_find_node_by_path(<span class="string">"/cpus"</span>);</div><div class="line"></div><div class="line">    for_each_child_of_node(cpus, cpu) &#123;       <span class="comment">/* 遍历cpus的所有的child node */</span></div><div class="line">        u32 hwid;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (of_node_cmp(cpu-&gt;type, <span class="string">"cpu"</span>))    <span class="comment">/* 我们只关心那些device_type是cpu的node */</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (of_property_read_u32(cpu, <span class="string">"reg"</span>, &amp;hwid)) &#123; <span class="comment">/* 读取reg属性的值并赋值给hwid */</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* reg的属性值的8 MSBs必须设置为0，这是ARM CPU binding定义的。 */</span></div><div class="line">        <span class="keyword">if</span> (hwid &amp; ~MPIDR_HWID_BITMASK)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* 不允许重复的CPU id，那是一个灾难性的设定 */</span></div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; cpuidx; j++)</div><div class="line">            <span class="keyword">if</span> (WARN(tmp_map[j] == hwid, <span class="string">"Duplicate /cpu reg "</span></div><div class="line">                             <span class="string">"properties in the DT\n"</span>))</div><div class="line">                <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* 数组tmp_map保存了系统中所有CPU的MPIDR值（CPU ID值），</span></div><div class="line">         * 具体的index的编码规则是： tmp_map[0]保存了booting CPU的id值，</div><div class="line">         * 其余的CPU的ID值保存在1～NR_CPUS的位置。</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (hwid == mpidr) &#123;</div><div class="line">            i = <span class="number">0</span>;</div><div class="line">            bootcpu_valid = <span class="literal">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            i = cpuidx++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        tmp_map[i] = hwid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 根据DTB中的信息设定cpu logical map数组。 */</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cpuidx; i++) &#123;</div><div class="line">        set_cpu_possible(i, <span class="literal">true</span>);</div><div class="line">        cpu_logical_map(i) = tmp_map[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要理解这部分的内容，需要理解ARM CUPs binding的概念，可以参考linux/Documentation/devicetree/bindings/arm目录下的CPU.txt文件的描述。</p>
<h3>memory的处理</h3>
<p>这部分的处理可以参考<code>setup_arch-&gt;setup_machine_fdt-&gt;early_init_dt_scan-&gt;early_init_dt_scan_memory</code>中的代码。具体如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __<span class="function">init <span class="title">early_init_dt_scan_memory</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> node, <span class="keyword">const</span> <span class="keyword">char</span> *uname,</span></span></div><div class="line">                     <span class="keyword">int</span> depth, <span class="keyword">void</span> *data)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> *type = of_get_flat_dt_prop(node, <span class="string">"device_type"</span>, <span class="literal">NULL</span>); <span class="comment">/* 获取device_type属性值 */</span></div><div class="line">    __be32 *reg, *endp;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> l;</div><div class="line"></div><div class="line">    <span class="comment">/* 在初始化的时候，我们会对每一个device node都要调用该call back函数，</span></div><div class="line">     * 因此，我们要过滤掉那些和memory block定义无关的node。</div><div class="line">     * 和memory block定义有的节点有两种，一种是node name是memory@形态的，</div><div class="line">     * 另外一种是node中定义了device_type属性并且其值是memory。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (type == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (depth != <span class="number">1</span> || <span class="built_in">strcmp</span>(uname, <span class="string">"memory@0"</span>) != <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(type, <span class="string">"memory"</span>) != <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 获取memory的起始地址和length的信息。</span></div><div class="line">     * 有两种属性和该信息有关，一个是linux,usable-memory，</div><div class="line">     * 不过最新的方式还是使用reg属性。</div><div class="line">     */</div><div class="line">    reg = of_get_flat_dt_prop(node, <span class="string">"linux,usable-memory"</span>, &amp;l);</div><div class="line">    <span class="keyword">if</span> (reg == <span class="literal">NULL</span>)</div><div class="line">        reg = of_get_flat_dt_prop(node, <span class="string">"reg"</span>, &amp;l);</div><div class="line">    <span class="keyword">if</span> (reg == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    endp = reg + (l / <span class="keyword">sizeof</span>(__be32));</div><div class="line"></div><div class="line">    <span class="comment">/* reg属性的值是address，size数组，那么如何来取出一个个的address/size呢？</span></div><div class="line">     * 由于memory node一定是root node的child，因此dt_root_addr_cells（root node的#address-cells属性值）</div><div class="line">     * 和dt_root_size_cells（root node的#size-cells属性值）之和就是address，size数组的entry size。</div><div class="line">     */</div><div class="line">    <span class="keyword">while</span> ((endp - reg) &gt;= (dt_root_addr_cells + dt_root_size_cells)) &#123;</div><div class="line">        u64 base, size;</div><div class="line"></div><div class="line">        base = dt_mem_next_cell(dt_root_addr_cells, &amp;reg;);</div><div class="line">        size = dt_mem_next_cell(dt_root_size_cells, &amp;reg;);</div><div class="line"></div><div class="line">        early_init_dt_add_memory_arch(base, size);  <span class="comment">/* 将具体的memory block信息加入到内核中。 */</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>interrupt controller的处理</h3>
<p>初始化是通过<code>start_kernel-&gt;init_IRQ-&gt;machine_desc-&gt;init_irq()</code>实现的。我们用S3C2416为例来描述interrupt controller的处理过程。下面是machine描述符的定义。
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">DT_MACHINE_START(S3C2416_DT, <span class="string">"Samsung S3C2416 (Flattened Device Tree)"</span>)</div><div class="line">    ……</div><div class="line">    .init_irq    = irqchip_init,</div><div class="line">    ……</div><div class="line">MACHINE_END</div></pre></td></tr></table></figure></p>
<p>在driver/irqchip/irq-s3c24xx.c文件中定义了两个interrupt controller，如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IRQCHIP_DECLARE(s3c2416_irq, <span class="string">"samsung,s3c2416-irq"</span>, s3c2416_init_intc_of);</div><div class="line">IRQCHIP_DECLARE(s3c2410_irq, <span class="string">"samsung,s3c2410-irq"</span>, s3c2410_init_intc_of);</div></pre></td></tr></table></figure></p>
<p>当然，系统中可以定义更多的irqchip，不过具体用哪一个是根据DTB中的interrupt controller node中的compatible属性确定的。在driver/irqchip/irqchip.c文件中定义了irqchip_init函数，如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">irqchip_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    of_irq_init(__irqchip_begin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>__irqchip_begin</code>就是所有的irqchip的一个列表，<code>of_irq_init</code>函数是遍历Device Tree，找到匹配的irqchip。具体的代码如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">of_irq_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> of_device_id *matches)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> device_node *np, *parent = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> intc_desc *desc, *temp_desc;</div><div class="line">    <span class="keyword">struct</span> list_head intc_desc_list, intc_parent_list;</div><div class="line"></div><div class="line">    INIT_LIST_HEAD(&amp;intc_desc_list);</div><div class="line">    INIT_LIST_HEAD(&amp;intc_parent_list);</div><div class="line"></div><div class="line">    <span class="comment">/* 遍历所有的node，寻找定义了interrupt-controller属性的node，</span></div><div class="line">     * 如果定义了interrupt-controller属性则说明该node就是一个中断控制器。</div><div class="line">     */</div><div class="line">    for_each_matching_node(np, matches) &#123;</div><div class="line">        <span class="keyword">if</span> (!of_find_property(np, <span class="string">"interrupt-controller"</span>, <span class="literal">NULL</span>) ||</div><div class="line">                !of_device_is_available(np))</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">     <span class="comment">/* 分配内存并挂入链表，当然还有根据interrupt-parent建立controller之间的父子关系。</span></div><div class="line">      * 对于interrupt controller，它也可能是一个树状的结构。</div><div class="line">      */</div><div class="line">        desc = kzalloc(<span class="keyword">sizeof</span>(*desc), GFP_KERNEL);</div><div class="line">        <span class="keyword">if</span> (WARN_ON(!desc))</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line"></div><div class="line">        desc-&gt;dev = np;</div><div class="line">        desc-&gt;interrupt_parent = of_irq_find_parent(np);</div><div class="line">        <span class="keyword">if</span> (desc-&gt;interrupt_parent == np)</div><div class="line">            desc-&gt;interrupt_parent = <span class="literal">NULL</span>;</div><div class="line">        list_add_tail(&amp;desc-&gt;<span class="built_in">list</span>, &amp;intc_desc_list);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 正因为interrupt controller被组织成树状的结构，因此初始化的顺序就需要控制，</span></div><div class="line">     * 应该从根节点开始，依次递进到下一个level的interrupt controller。</div><div class="line">     */</div><div class="line">    <span class="keyword">while</span> (!list_empty(&amp;intc_desc_list)) &#123;</div><div class="line">        <span class="comment">/* intc_desc_list链表中的节点会被一个个的处理，</span></div><div class="line">         * 每处理完一个节点就会将该节点删除，当所有的节点被删除，整个处理过程也就是结束了。</div><div class="line">         */</div><div class="line">        list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, <span class="built_in">list</span>) &#123;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">struct</span> of_device_id *match;</div><div class="line">            <span class="keyword">int</span> ret;</div><div class="line">            <span class="keyword">of_irq_init_cb_t</span> irq_init_cb;</div><div class="line"></div><div class="line">            <span class="comment">/* 最开始的时候parent变量是NULL，确保第一个被处理的是root interrupt controller。</span></div><div class="line">             * 在处理完root node之后，parent变量被设定为root interrupt controller，</div><div class="line">             * 因此，第二个循环中处理的是所有parent是root interrupt controller的child interrupt controller。</div><div class="line">             * 也就是level 1（如果root是level 0的话）的节点。</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (desc-&gt;interrupt_parent != parent)</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">            list_del(&amp;desc-&gt;<span class="built_in">list</span>);                     <span class="comment">/* 从链表中删除 */</span></div><div class="line">            match = of_match_node(matches, desc-&gt;dev); <span class="comment">/* 匹配并初始化 */</span></div><div class="line">            <span class="keyword">if</span> (WARN(!match-&gt;data,                     <span class="comment">/* match-&gt;data是初始化函数 */</span></div><div class="line">                <span class="string">"of_irq_init: no init function for %s\n"</span>,</div><div class="line">                match-&gt;compatible)) &#123;</div><div class="line">                kfree(desc);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            irq_init_cb = (<span class="keyword">of_irq_init_cb_t</span>)match-&gt;data;</div><div class="line">            ret = irq_init_cb(desc-&gt;dev, desc-&gt;interrupt_parent); <span class="comment">/* 执行初始化函数 */</span></div><div class="line">            <span class="keyword">if</span> (ret) &#123;</div><div class="line">                kfree(desc);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* 处理完的节点放入intc_parent_list链表，后面会用到 */</span></div><div class="line">            list_add_tail(&amp;desc-&gt;<span class="built_in">list</span>, &amp;intc_parent_list);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* 对于level 0，只有一个root interrupt controller，</span></div><div class="line">         * 对于level 1，可能有若干个interrupt controller，</div><div class="line">         * 因此要遍历这些parent interrupt controller，以便处理下一个level的child node。</div><div class="line">         */</div><div class="line">        desc = list_first_entry_or_null(&amp;intc_parent_list,</div><div class="line">                        typeof(*desc), <span class="built_in">list</span>);</div><div class="line">        <span class="keyword">if</span> (!desc) &#123;</div><div class="line">            pr_err(<span class="string">"of_irq_init: children remain, but no parents\n"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        list_del(&amp;desc-&gt;<span class="built_in">list</span>);</div><div class="line">        parent = desc-&gt;dev;</div><div class="line">        kfree(desc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    list_for_each_entry_safe(desc, temp_desc, &amp;intc_parent_list, <span class="built_in">list</span>) &#123;</div><div class="line">        list_del(&amp;desc-&gt;<span class="built_in">list</span>);</div><div class="line">        kfree(desc);</div><div class="line">    &#125;</div><div class="line">err:</div><div class="line">    list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, <span class="built_in">list</span>) &#123;</div><div class="line">        list_del(&amp;desc-&gt;<span class="built_in">list</span>);</div><div class="line">        kfree(desc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只有该node中有<code>interrupt-controller</code>这个属性定义，那么linux kernel就会分配一个interrupt controller的描述符（<code>struct intc_desc</code>）并挂入队列。通过<code>interrupt-parent</code>属性，可以确定各个interrupt controller的层次关系。在scan了所有的Device Tree中的interrupt controller的定义之后，系统开始匹配过程。一旦匹配到了interrupt chip列表中的项次后，就会调用相应的初始化函数。如果CPU是S3C2416的话，匹配到的是irqchip的初始化函数是<code>s3c2416_init_intc_of</code>。</p>
<p>OK，我们已经通过<code>compatible</code>属性找到了适合的interrupt controller，那么如何解析reg属性呢？我们知道，对于s3c2416的interrupt controller而言，其<code>#interrupt-cells</code>的属性值是4，定义为。每个域的解释如下：</p>
<p>（1）ctrl_num表示使用哪一种类型的interrupt controller，其值的解释如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- 0 ... main controller</div><div class="line">- 1 ... sub controller</div><div class="line">- 2 ... second main controller</div></pre></td></tr></table></figure></p>
<p>（2）parent_irq。对于sub controller，parent_irq标识了其在main controller的bit position。
（3）ctrl_irq标识了在controller中的bit位置。
（4）type标识了该中断的trigger type，例如：上升沿触发还是电平触发。</p>
<p>为了更顺畅的描述后续的代码，我需要简单的介绍2416的中断控制器，其block diagram如下：

53个Samsung2416的中断源被分成两种类型，一种是需要sub寄存器进行控制的，例如DMA，系统中的8个DMA中断是通过两级识别的，先在SRCPND寄存器中得到是DMA中断的信息，具体是哪一个channel的DMA中断需要继续查询SUBSRC寄存器。那些不需要sub寄存器进行控制的，例如timer，5个timer的中断可以直接从SRCPND中得到。
中断MASK寄存器可以控制产生的中断是否要报告给CPU，当一个中断被mask的时候，虽然SRCPND寄存器中，硬件会set该bit，但是不会影响到INTPND寄存器，从而不会向CPU报告该中断。对于SUBMASK寄存器，如果该bit被set，也就是该sub中断被mask了，那么即便产生了对应的sub中断，也不会修改SRCPND寄存器的内容，只是修改SUBSRCPND中寄存器的内容。</p>
<p>不过随着硬件的演化，更多的HW block加入到SOC中，这使得中断源不够用了，因此中断寄存器又被分成两个group，一个是group 1（开始地址是<code>0X4A000000</code>，也就是main controller了），另外一个是group2（开始地址是<code>0X4A000040</code>，叫做second main controller）。group 1中的sub寄存器的起始地址是<code>0X4A000018</code>（也就是sub controller）。</p>
<p>了解了上面的内容后，下面的定义就比较好理解了：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> s3c24xx_irq_of_ctrl s3c2416_ctrl[] = &#123;</div><div class="line">    &#123;</div><div class="line">        .name = <span class="string">"intc"</span>,               <span class="comment">/* main controller */</span></div><div class="line">        .offset = <span class="number">0</span>,</div><div class="line">    &#125;, &#123;</div><div class="line">        .name = <span class="string">"subintc"</span>,            <span class="comment">/* sub controller */</span></div><div class="line">        .offset = <span class="number">0x18</span>,</div><div class="line">        .parent = &amp;s3c_intc[<span class="number">0</span>],</div><div class="line">    &#125;, &#123;</div><div class="line">        .name = <span class="string">"intc2"</span>,              <span class="comment">/* second main controller */</span></div><div class="line">        .offset = <span class="number">0x40</span>,</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>对于s3c2416而言，irqchip的初始化函数是<code>s3c2416_init_intc_of</code>，<code>s3c2416_ctrl</code>作为参数传递给了<code>s3c_init_intc_of</code>，大部分的处理都是在<code>s3c_init_intc_of</code>函数中完成的，由于这个函数和中断子系统非常相关，这里就不详述了，后续会有一份专门的文档描述之。</p>
<h3>GPIO controller的处理</h3>
<p>暂不描述，后续会有一份专门的文档描述GPIO sub system。</p>
<h3>machine初始化</h3>
<p>machine初始化的代码可以沿着<code>start_kernel-&gt;rest_init-&gt;kernel_init-&gt;kernel_init_freeable-&gt;do_basic_setup-&gt;do_initcalls</code>路径寻找。在<code>do_initcalls</code>函数中，kernel会依次执行各个<code>initcall</code>函数，在这个过程中，会调用<code>customize_machine</code>，具体如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">customize_machine</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (machine_desc-&gt;init_machine)</div><div class="line">        machine_desc-&gt;init_machine();</div><div class="line">    <span class="keyword">else</span></div><div class="line">        of_platform_populate(<span class="literal">NULL</span>, of_default_bus_match_table, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">arch_initcall(customize_machine);</div></pre></td></tr></table></figure></p>
<p>在这个函数中，一般会调用machine描述符中的<code>init_machine callback</code>函数来把各种Device Tree中定义各个设备节点加入到系统。如果machine描述符中没有定义<code>init_machine</code>函数，那么直接调用<code>of_platform_populate</code>把所有的platform device加入到kernel中。对于s3c2416，其machine描述符中的<code>init_machine callback</code>函数就是<code>s3c2416_dt_machine_init</code>，代码如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">init <span class="title">s3c2416_dt_machine_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    of_platform_populate(<span class="literal">NULL</span>, <span class="comment">/* 传入NULL参数表示从root node开始scan */</span></div><div class="line">        of_default_bus_match_table, s3c2416_auxdata_lookup, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    s3c_pm_init();             <span class="comment">/* power management相关的初始化 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此可见，最终生成platform device的代码来自<code>of_platform_populate</code>函数。该函数的逻辑比较简单，遍历device node global list中所有的node，并调用<code>of_platform_bus_create</code>处理，<code>of_platform_bus_create</code>函数代码如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">of_platform_bus_create</span><span class="params">(<span class="keyword">struct</span> device_node *bus, <span class="comment">/* 要创建的那个device node */</span></span></span></div><div class="line">                  <span class="keyword">const</span> <span class="keyword">struct</span> of_device_id *matches,      <span class="comment">/* 要匹配的list */</span></div><div class="line">                  <span class="keyword">const</span> <span class="keyword">struct</span> of_dev_auxdata *lookup,     <span class="comment">/* 附属数据 */</span></div><div class="line">                  <span class="keyword">struct</span> device *parent, <span class="keyword">bool</span> strict)      <span class="comment">/* parent指向父节点。strict是否要求完全匹配 */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> of_dev_auxdata *auxdata;</div><div class="line">    <span class="keyword">struct</span> device_node *child;</div><div class="line">    <span class="keyword">struct</span> platform_device *dev;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *bus_id = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">void</span> *platform_data = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 删除确保device node有compatible属性的代码。 */</span></div><div class="line"></div><div class="line">    auxdata = of_dev_lookup(lookup, bus); <span class="comment">/* 在传入的lookup table寻找和该device node匹配的附加数据 */</span></div><div class="line">    <span class="keyword">if</span> (auxdata) &#123;</div><div class="line">        bus_id = auxdata-&gt;name;           <span class="comment">/* 如果找到，那么就用附加数据中的静态定义的内容 */</span></div><div class="line">        platform_data = auxdata-&gt;platform_data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* ARM公司提供了CPU core，除此之外，它设计了AMBA的总线来连接SOC内的各个block。</span></div><div class="line">     * 符合这个总线标准的SOC上的外设叫做ARM Primecell Peripherals。</div><div class="line">     * 如果一个device node的compatible属性值是arm,primecell的话，</div><div class="line">     * 可以调用of_amba_device_create来向amba总线上增加一个amba device。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (of_device_is_compatible(bus, <span class="string">"arm,primecell"</span>)) &#123;</div><div class="line">        of_amba_device_create(bus, bus_id, platform_data, parent);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 如果不是ARM Primecell Peripherals，那么我们就需要向platform bus上增加一个platform device了 */</span></div><div class="line">    dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);</div><div class="line">    <span class="keyword">if</span> (!dev || !of_match_node(matches, bus))</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 一个device node可能是一个桥设备，因此要重复调用of_platform_bus_create来把所有的device node处理掉。 */</span></div><div class="line"></div><div class="line">    for_each_child_of_node(bus, child) &#123;</div><div class="line">        pr_debug(<span class="string">"   create child: %s\n"</span>, child-&gt;full_name);</div><div class="line">        rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);</div><div class="line">        <span class="keyword">if</span> (rc) &#123;</div><div class="line">            of_node_put(child);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> rc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体增加platform device的代码在<code>of_platform_device_create_pdata</code>中，代码如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> platform_device *<span class="title">of_platform_device_create_pdata</span><span class="params">(</span></span></div><div class="line">                    <span class="keyword">struct</span> device_node *np,</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">char</span> *bus_id,</div><div class="line">                    <span class="keyword">void</span> *platform_data,</div><div class="line">                    <span class="keyword">struct</span> device *parent)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> platform_device *dev;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!of_device_is_available(np)) <span class="comment">/* check status属性，确保是enable或者OK的。 */</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* of_device_alloc除了分配struct platform_device的内存，</span></div><div class="line">     * 还分配了该platform device需要的resource的内存（参考struct platform_device 中的resource成员）。</div><div class="line">     * 当然，这就需要解析该device node的interrupt资源以及memory address资源。</div><div class="line">     */</div><div class="line">    dev = of_device_alloc(np, bus_id, parent);</div><div class="line">    <span class="keyword">if</span> (!dev)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 设定platform_device 中的其他成员 */</span></div><div class="line">    dev-&gt;dev.coherent_dma_mask = DMA_BIT_MASK(<span class="number">32</span>);</div><div class="line">    <span class="keyword">if</span> (!dev-&gt;dev.dma_mask)</div><div class="line">        dev-&gt;dev.dma_mask = &amp;dev-&gt;dev.coherent_dma_mask;</div><div class="line">    dev-&gt;dev.bus = &amp;platform_bus_type;</div><div class="line">    dev-&gt;dev.platform_data = platform_data;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (of_device_add(dev) != <span class="number">0</span>) &#123; <span class="comment">/* 把这个platform device加入统一设备模型系统中 */</span></div><div class="line">        platform_device_put(dev);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dev;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&lt;span style=&quot;color:red;&quot;&gt;PS: 上述分析中的 of_* 函数，其 of_ 前缀为Open Firmware的缩写？&lt;/span&gt;</p>

    

    
</div>


                

                <!-- Post Comments -->
                
                    







                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2015/04/21/Longest-Common-Substring/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            新篇
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2015/04/28/vh-center-layout/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="John Doe's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        youremail@email.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="#" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/" target="_self">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2017/04/">四月 2017<span class="sidebar_archives-count">28</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/03/">三月 2017<span class="sidebar_archives-count">37</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/02/">二月 2017<span class="sidebar_archives-count">12</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/01/">一月 2017<span class="sidebar_archives-count">12</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/12/">十二月 2016<span class="sidebar_archives-count">18</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/11/">十一月 2016<span class="sidebar_archives-count">24</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/10/">十月 2016<span class="sidebar_archives-count">39</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/09/">九月 2016<span class="sidebar_archives-count">32</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/08/">八月 2016<span class="sidebar_archives-count">32</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/07/">七月 2016<span class="sidebar_archives-count">21</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/06/">六月 2016<span class="sidebar_archives-count">33</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/05/">五月 2016<span class="sidebar_archives-count">20</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/04/">四月 2016<span class="sidebar_archives-count">15</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/03/">三月 2016<span class="sidebar_archives-count">19</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/02/">二月 2016<span class="sidebar_archives-count">16</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/01/">一月 2016<span class="sidebar_archives-count">19</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/12/">十二月 2015<span class="sidebar_archives-count">20</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/11/">十一月 2015<span class="sidebar_archives-count">30</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/10/">十月 2015<span class="sidebar_archives-count">30</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/09/">九月 2015<span class="sidebar_archives-count">27</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/08/">八月 2015<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/07/">七月 2015<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/06/">六月 2015<span class="sidebar_archives-count">10</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/05/">五月 2015<span class="sidebar_archives-count">7</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/04/">四月 2015<span class="sidebar_archives-count">11</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/03/">三月 2015<span class="sidebar_archives-count">10</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/02/">二月 2015<span class="sidebar_archives-count">14</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/01/">一月 2015<span class="sidebar_archives-count">6</span></a></li><li><a class="sidebar_archives-link" href="/archives/2014/12/">十二月 2014<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2014/11/">十一月 2014<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2014/10/">十月 2014<span class="sidebar_archives-count">6</span></a></li><li><a class="sidebar_archives-link" href="/archives/2014/09/">九月 2014<span class="sidebar_archives-count">6</span></a></li><li><a class="sidebar_archives-link" href="/archives/2014/08/">八月 2014<span class="sidebar_archives-count">9</span></a></li><li><a class="sidebar_archives-link" href="/archives/2014/07/">七月 2014<span class="sidebar_archives-count">6</span></a></li><li><a class="sidebar_archives-link" href="/archives/2014/06/">六月 2014<span class="sidebar_archives-count">7</span></a></li><li><a class="sidebar_archives-link" href="/archives/2014/05/">五月 2014<span class="sidebar_archives-count">11</span></a></li><li><a class="sidebar_archives-link" href="/archives/2014/04/">四月 2014<span class="sidebar_archives-count">32</span></a></li><li><a class="sidebar_archives-link" href="/archives/2014/03/">三月 2014<span class="sidebar_archives-count">34</span></a></li><li><a class="sidebar_archives-link" href="/archives/2014/02/">二月 2014<span class="sidebar_archives-count">14</span></a></li><li><a class="sidebar_archives-link" href="/archives/2014/01/">一月 2014<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2013/12/">十二月 2013<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2013/07/">七月 2013<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2013/06/">六月 2013<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2013/04/">四月 2013<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2013/03/">三月 2013<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2013/02/">二月 2013<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2013/01/">一月 2013<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2012/12/">十二月 2012<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2012/10/">十月 2012<span class="sidebar_archives-count">6</span></a></li><li><a class="sidebar_archives-link" href="/archives/2012/09/">九月 2012<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2012/07/">七月 2012<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2012/06/">六月 2012<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2012/05/">五月 2012<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2011/08/">八月 2011<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2011/07/">七月 2011<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2011/06/">六月 2011<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2011/05/">五月 2011<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2011/04/">四月 2011<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2011/03/">三月 2011<span class="sidebar_archives-count">5</span></a></li><li><a class="sidebar_archives-link" href="/archives/2011/02/">二月 2011<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2010/12/">十二月 2010<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2010/11/">十一月 2010<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2010/09/">九月 2010<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2010/07/">七月 2010<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2010/06/">六月 2010<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2010/02/">二月 2010<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2010/01/">一月 2010<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2009/09/">九月 2009<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2009/07/">七月 2009<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2009/05/">五月 2009<span class="sidebar_archives-count">5</span></a></li><li><a class="sidebar_archives-link" href="/archives/2009/04/">四月 2009<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2009/03/">三月 2009<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2009/02/">二月 2009<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2008/07/">七月 2008<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2008/06/">六月 2008<span class="sidebar_archives-count">1</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            主题 - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn" style="background-image: url(/img/footer/footer_ico-twitter.svg);">
                <span class="visuallyhidden">Twitter</span>
            </button><!--
     --></a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn" style="background-image: url(/img/footer/footer_ico-facebook.svg);">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn" style="background-image: url(/img/footer/footer_ico-gplus.svg);">
                <span class="visuallyhidden">Google Plus</span>
            </button><!--
     --></a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;
            <script type="text/javascript">
                var fd = new Date();
                document.write(fd.getFullYear());
            </script>
            &nbsp;Hexo
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import File -->

    <script src="/js/lazyload.min.js"></script>
    <script src="/js/js.min.js"></script>



    <script src="/js/nprogress.js"></script>


<script type="text/javascript">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>
















<!-- Window Load-->
<script>
    $(window).load(function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });
</script>

<!-- MathJax Load-->

<script>
    <!-- Offer LazyLoad -->
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    <!-- Start Queue -->
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

                </main>
            </div>
        </body>
    
</html>
